[{"id":0,"href":"/posts/rust_tonic_learn1/","title":"Rust学习之tonic-一个grpc的rust实现","section":"心得笔记","content":"\rtonic简介（引用自\rcrates.io）\r#\rA rust implementation of gRPC, a high performance, open source, general RPC framework that puts mobile and HTTP/2 first. tonic is a gRPC over HTTP/2 implementation focused on high performance, interoperability, and flexibility. This library was created to have first class support of async/await and to act as a core building block for production systems written in Rust.\ntonic特点：\r#\r由rust社区使用rust语言实现 脱离google官方grpc工具链，如protoc 支持rust异步运行时 支持build.rs tonic使用笔记\r#\rCargo.toml中引入相关依赖\r#\r[dependencies] tonic = \u0026#34;0.7.2\u0026#34; # 包含grpc中的核心功能，如开启服务监听等 prost = \u0026#34;0.10\u0026#34; # 主要用于处理proto生成的rust源代码，如序列化、反序列化消息 tokio = {version = \u0026#34;1.20.0\u0026#34;, features = [\u0026#34;rt-multi-thread\u0026#34;, \u0026#34;time\u0026#34;, \u0026#34;fs\u0026#34;, \u0026#34;macros\u0026#34;, \u0026#34;net\u0026#34;]} # 目前的主流rust异步运行时 [build-dependencies] tonic-build = \u0026#34;0.7.2\u0026#34; # 编译时依赖，顾名思义，主要为build.rs提供编译protoc的相关功能 编写protoc文件（这里以tonic官方示例做演示）\r#\r// proto/echo/echo.proto syntax = \u0026#34;proto3\u0026#34;; package grpc.examples.echo; // EchoRequest is the request for echo. message EchoRequest { string message = 1; } // EchoResponse is the response for echo. message EchoResponse { string message = 1; } // Echo is the echo service. service Echo { // UnaryEcho is unary echo. rpc UnaryEcho(EchoRequest) returns (EchoResponse) {} } 编写build.rs\r#\rfn main(){ tonic_build::compile_protos(\u0026#34;proto/echo/echo.proto\u0026#34;).unwrap(); } 知识扩展\r#\rtonic支持一些生成配置，如添加自定义trait、自定义输出目录等，可使用tonic_build::configure()来操作这些属性 // 自定义proto产出文件的保存目录，如不自定义这个的化，需要使用 tonic的相关宏来引入（后续展开说明） // 自定义proto产出文件相关结构体的 message-\u0026gt;struct 的derive宏属性 tonic_build::configure().out_dir(\u0026#34;src/\u0026#34;).type_attribute(\u0026#34;.\u0026#34;, \u0026#34;#[derive(serde::Serialize, serde::Deserialize)]\u0026#34;).compile( \u0026amp;[\u0026#34;proto/echo/echo.proto\u0026#34;], \u0026amp;[\u0026#34;protobuf\u0026#34;] ).unwrap(); 创建并开启grpc服务\r#\ruse echo::{EchoRequest,EchoResponse,echo_server::{Echo,EchoServer}}; use prost::Message; use tonic::{Response, transport::Server}; pub mod echo { // 因为上面的build.rs没有定义产出rust源文件的输出目录，所以这里需要使用这个宏来引用你proto对应的rust文件 // grpc.examples.echo 对应的是 proto 文件中的 package 属性 tonic::include_proto!(\u0026#34;grpc.examples.echo\u0026#34;); } #[derive(Default,Debug)] struct MyServer{} // 这里使用异步的方式来实现服务 #[tonic::async_trait] impl Echo for MyServer{ async fn unary_echo( \u0026amp;self, request: tonic::Request\u0026lt;EchoRequest\u0026gt;, ) -\u0026gt; Result\u0026lt;tonic::Response\u0026lt;EchoResponse\u0026gt;, tonic::Status\u0026gt;{ println!(\u0026#34;remote addr:{:?} message:{:?}\u0026#34;,request.remote_addr(),request.get_ref().message); let reply = EchoResponse{ message:format!(\u0026#34;hi client:{:?}\u0026#34;,request.remote_addr()) }; // 序列化和反序列化测试，这里的主要功能由 prost 包提供 let buf = reply.encode_to_vec(); println!(\u0026#34;proto encode buf:{:?}\u0026#34;,buf); let r:EchoResponse = Message::decode(\u0026amp;buf[..buf.len()]).unwrap(); println!(\u0026#34;decode:{:?}\u0026#34;,r.message); Ok(Response::new(reply)) } } #[tokio::main] async fn main() { let addr = \u0026#34;[::1]:50051\u0026#34;.parse().unwrap(); let echo = MyServer::default(); println!(\u0026#34;EchoServer listening on {}\u0026#34;, addr); Server::builder() .add_service(EchoServer::new(echo)) .serve(addr) .await.unwrap(); } 创建客户端\r#\rpub mod echo { tonic::include_proto!(\u0026#34;grpc.examples.echo\u0026#34;); } #[tokio::main] async fn main(){ let mut echo_client = echo::echo_client::EchoClient::connect(\u0026#34;http://[::1]:50051\u0026#34;).await.unwrap(); let request = tonic::Request::new(echo::EchoRequest{ message: \u0026#34;hi server\u0026#34;.into() }); let resp = echo_client.unary_echo(request).await.unwrap(); println!(\u0026#34;recv server data:{:?}\u0026#34;,resp.get_ref().message); } 启动服务端并测试\r#\rclient output: Compiling test_0 v0.1.0 (/home/oldcat/project/rust/test_0) Finished dev [unoptimized + debuginfo] target(s) in 6.00s Running `target/debug/client` recv server data:\u0026#34;hi client:Some([::1]:47758)\u0026#34; "},{"id":1,"href":"/docs/open-source/others/Go/","title":"Go","section":"其它开源项目","content":"\r3rd Level of Menu\r#\rNefas discordemque domino montes numen tum humili nexilibusque exit, Iove. Quae miror esse, scelerisque Melaneus viribus. Miseri laurus. Hoc est proposita me ante aliquid, aura inponere candidioribus quidque accendit bella, sumpta. Intravit quam erat figentem hunc, motus de fontes parvo tempestate.\niscsi_virus = pitch(json_in_on(eupViral),\rnorthbridge_services_troubleshooting, personal(\rfirmware_rw.trash_rw_crm.device(interactive_gopher_personal,\rsoftware, -1), megabit, ergonomicsSoftware(cmyk_usb_panel,\rmips_whitelist_duplex, cpa)));\rif (5) {\rmanagementNetwork += dma - boolean;\rkilohertz_token = 2;\rhoneypot_affiliate_ergonomics = fiber;\r}\rmouseNorthbridge = byte(nybble_xmp_modem.horse_subnet(\ranalogThroughputService * graphicPoint, drop(daw_bit, dnsIntranet),\rgateway_ospf), repository.domain_key.mouse(serverData(fileNetwork,\rtrim_duplex_file), cellTapeDirect, token_tooltip_mashup(\rripcordingMashup)));\rmodule_it = honeypot_driver(client_cold_dvr(593902, ripping_frequency) +\rcoreLog.joystick(componentUdpLink), windows_expansion_touchscreen);\rbashGigabit.external.reality(2, server_hardware_codec.flops.ebookSampling(\rciscNavigationBacklink, table + cleanDriver), indexProtocolIsp);\r"}]